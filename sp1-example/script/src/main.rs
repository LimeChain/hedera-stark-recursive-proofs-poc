//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be verified
//! on-chain.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin prove --release
//! ```

use std::path::PathBuf;

use alloy_sol_types::{sol, SolType};
use ark_bn254::{Fr, G1Projective, G2Projective};
use ark_ec::Group;
use ark_ff::PrimeField;
use ark_serialize::CanonicalSerialize;
use ark_std::UniformRand;
use clap::Parser;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha384};
use sp1_sdk::{
    utils, HashableKey, ProverClient, SP1Proof, SP1ProofWithPublicValues, SP1ProvingKey, SP1Stdin,
    SP1VerifyingKey,
};

mod cli;

pub type SignatureInput = (Vec<u8>, Vec<u8>, Vec<u8>);

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const PROOFS_ELF: &[u8] = include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");
const BASE_FOLDER: &str = env!("CARGO_MANIFEST_DIR");
const EXAMPLES_FOLDER_NAME: &str = "../examples";

/// The arguments for the prove command.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    #[clap(long, default_value = "20")]
    n: u32,

    #[clap(long, default_value = "false")]
    evm: bool,
}
struct AggregationInput {
    pub proof: SP1ProofWithPublicValues,
    pub vk: SP1VerifyingKey,
}

fn main() -> Result<(), anyhow::Error> {
    // Setup the logger.
    utils::setup_logger();

    let matches: clap::ArgMatches = cli::initialize().get_matches();
    // Setup the prover client.
    if matches.get_flag("demo") {
        run_demo()?;
    } else {
        run_prover(&matches)?;
    }

    Ok(())
}

fn run_prover(matches: &clap::ArgMatches) -> Result<(), anyhow::Error> {
    let pubkey_0_hex = matches
        .get_one::<String>("pubkey0")
        .unwrap()
        .trim_start_matches("0x")
        .to_owned();
    let pubkey_0: Vec<u8> = hex::decode(pubkey_0_hex)?;
    let receipt: Option<&String> = matches.get_one::<String>("receipt");

    let (privkey_1, privkey_2) = generate_private_keys()?;

    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(PROOFS_ELF);

    let proof = match receipt {
        None => generate_assumption(pubkey_0.clone(), privkey_1, &client, &pk, &vk)?,
        Some(receipt_path) => {
            // Load the proof from file
            SP1ProofWithPublicValues::load(receipt_path)?
        }
    };

    let input = AggregationInput {
        proof,
        vk: vk.clone(),
    };

    let vk_hash = input.vk.hash_u32();
    let public_inputs = input.proof.public_values.to_vec();
    let deserialized: (Vec<u8>, Vec<u8>) = bincode::deserialize(&public_inputs).unwrap();

    let aggr_inputs = generate_inputs(deserialized.1, privkey_2)?;

    // Setup the inputs.
    let mut stdin = SP1Stdin::new();
    stdin.write(&aggr_inputs);
    stdin.write::<Vec<[u32; 8]>>(&vec![vk_hash]);
    stdin.write(&vec![public_inputs]);
    stdin.write::<Vec<u8>>(&pubkey_0);

    let SP1Proof::Compressed(proof) = input.proof.proof else {
        panic!()
    };
    stdin.write_proof(proof, input.vk.vk);

    let aggr_proof = client
        .prove(&pk, stdin.clone())
        .compressed()
        .run()
        .expect("failed to generate proof");

    // Verify the proof.
    client
        .verify(&aggr_proof, &vk)
        .expect("failed to verify proof");

    aggr_proof.save(format!(
        "{}/{}/aggr_proof.bin",
        BASE_FOLDER, EXAMPLES_FOLDER_NAME
    ))?;

    // Generate PLONK proof for on-chain verification.
    if matches.get_flag("plonk") {
        let plonk_proof = client
            .prove(&pk, stdin)
            .plonk()
            .run()
            .expect("failed to generate proof");

        client
            .verify(&plonk_proof, &vk)
            .expect("failed to verify proof");

        plonk_proof.save(format!(
            "{}/{}/plonk_proof.bin",
            BASE_FOLDER, EXAMPLES_FOLDER_NAME
        ))?;

        create_plonk_fixture(&plonk_proof, &vk);
    }

    Ok(())
}

fn run_demo() -> Result<(), anyhow::Error> {
    let client = ProverClient::new();

    // Setup the program.
    let (_, vk) = client.setup(PROOFS_ELF);

    let plonk_proof = SP1ProofWithPublicValues::load(format!(
        "{}/{}/plonk_proof.bin",
        BASE_FOLDER, EXAMPLES_FOLDER_NAME
    ))?;

    create_plonk_fixture(&plonk_proof, &vk);

    Ok(())
}

fn generate_inputs(
    message_bytes: Vec<u8>,
    privkey_new: Fr,
) -> Result<crate::SignatureInput, anyhow::Error> {
    let g1_gen: G1Projective = G1Projective::generator();
    let g2_gen: G2Projective = G2Projective::generator();

    let pubkey_new: G2Projective = g2_gen * privkey_new;

    let mut pubkey_new_bytes: Vec<u8> = Vec::new();
    pubkey_new
        .serialize_compressed(&mut pubkey_new_bytes)
        .unwrap();

    let mut hasher = Sha384::new();
    hasher.update(message_bytes);
    let message_hash = hasher.finalize();
    let g1_message: G1Projective = g1_gen * Fr::from_le_bytes_mod_order(message_hash.as_slice());
    let mut g1_message_bytes: Vec<u8> = Vec::new();
    g1_message
        .serialize_compressed(&mut g1_message_bytes)
        .unwrap();

    let signature: G1Projective = g1_message * privkey_new;

    let mut signature_bytes: Vec<u8> = Vec::new();
    signature
        .serialize_compressed(&mut signature_bytes)
        .unwrap();

    Ok((pubkey_new_bytes, g1_message_bytes, signature_bytes))
}

fn generate_assumption(
    pubkey_0: Vec<u8>,
    privkey_1: Fr,
    client: &ProverClient,
    pk: &SP1ProvingKey,
    vk: &SP1VerifyingKey,
) -> Result<SP1ProofWithPublicValues, anyhow::Error> {
    let inputs = generate_inputs(pubkey_0.clone(), privkey_1)?;

    let mut stdin = SP1Stdin::new();
    stdin.write(&inputs);
    stdin.write::<Vec<[u32; 8]>>(&vec![]);
    stdin.write::<Vec<Vec<u8>>>(&vec![]);
    stdin.write::<Vec<u8>>(&pubkey_0);

    let proof = client
        .prove(pk, stdin)
        .compressed()
        .run()
        .expect("failed to generate proof");

    client.verify(&proof, vk).expect("failed to verify proof");

    proof.save(format!(
        "{}/{}/assumption_proof.bin",
        BASE_FOLDER, EXAMPLES_FOLDER_NAME
    ))?;

    Ok(proof)
}

fn generate_private_keys() -> Result<(Fr, Fr), anyhow::Error> {
    let mut rng = ark_std::test_rng();
    let _ = Fr::rand(&mut rng); // This is the private key for the zero epoch, we don't need it here
    let privkey_1 = Fr::rand(&mut rng);
    let privkey_2 = Fr::rand(&mut rng);

    Ok((privkey_1, privkey_2))
}

/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SP1FibonacciProofFixture {
    vkey: String,
    public_values: String,
    proof: String,
}

/// Create a fixture for the given proof.
fn create_plonk_fixture(proof: &SP1ProofWithPublicValues, vk: &SP1VerifyingKey) {
    // Deserialize the public values.
    let bytes = proof.public_values.as_slice();

    // Create the testing fixture so we can test things end-ot-end.
    let fixture = SP1FibonacciProofFixture {
        vkey: vk.bytes32().to_string(),
        public_values: format!("0x{}", hex::encode(bytes)),
        proof: format!("0x{}", hex::encode(proof.bytes())),
    };

    // The verification key is used to verify that the proof corresponds to the execution of the
    // program on the given input.
    //
    // Note that the verification key stays the same regardless of the input.
    println!("Verification Key: {}", fixture.vkey);

    // The public values are the values whicha are publically commited to by the zkVM.
    //
    // If you need to expose the inputs or outputs of your program, you should commit them in
    // the public values.
    println!("Public Values: {}", fixture.public_values);

    // The proof proves to the verifier that the program was executed with some inputs that led to
    // the give public values.
    println!("Proof Bytes: {}", fixture.proof);

    // Save the fixture to a file.
    let fixture_path = PathBuf::from(BASE_FOLDER).join(EXAMPLES_FOLDER_NAME);
    std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
    std::fs::write(
        fixture_path.join("fixture.json"),
        serde_json::to_string_pretty(&fixture).unwrap(),
    )
    .expect("failed to write fixture");
}
